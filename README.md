//스터디 워치 만들가
//useRef를 사용해서 타이머 시작하고 끄기

1. useState

2. useRef
   current속성을 가지고 있는 객체를 반환하는데,인자로 넘어온 초기값을 current속성에 할당한다. current속성은 값을 변경해도 state를 변경할 때처럼 컴포넌트가 다시 렌더링되지 않는다. 컴포넌트가 다시 렌더링될때도 마찬가지로 이 current 속성의 값의 유실되지 않는다. 컴포넌트가 렌더링이 필요하지 않은 상태에서 그 속성에 접근해야 하거나, 또는 어떠한 Dom에 접근해야 할때 useRef를 사용하면 좋다.

3. useCallback
   특정 함수를 재사용하고 싶을 때 사용한다. 함수들은 렌더링될때 마다 새로 만들어지며, 이는 효율성을 저하시킨다.나중에 props가 바뀌지 않으면 DOM에 새로 렌더링을 하지 않는 작업을 하기 위해서는 함수를 재사용해야 한다.
   한 파일에서 callback함수로 만든 함수를 다른 파일에서 props로 전달받아 사용할 수 있다.
4. useMemo

- 장점
  복잡하고 어려운 계산(함수)가 반복적으로 일어나지 않도록 값을 저장해서
  쓸 수 있게 한다. 두번째 인자로 들어온 의존성 배열이 업데이트 될때에만
  계산을 다시 실행하고 그 값을 저장한다.

- 단점
  값을 저장한다는 것은 메모리를 소비한다는 뜻이다. 재활용되지도 않을 불필요한
  값을 useMemo로 쓰면 메모리가 낭비될 수 있다. 필요할때만 사용하는 것이
  중요하다!

5. React.memo
   부모 컴포넌트가 렌더링이 되면 자식 컴포넌트도 자동으로 렌더링이 된다.
   이때 자식 컴포넌트가 부모에게서 받은 props가 동일하다면, 같은 렌더링이
   불필요하게 일어나게 되는 것이다.
   이때 props의 변경사항이 없을 경우 자식 컴포넌트의 렌더링을 방지해주는 것이
   React.memo이다.

   1. 컴포넌트가 같은 Props로 자주 렌더링 될때 컴포넌트가 렌더링이 될때마다 2) 2) 복잡한 로직을 처리해야 한다면

   react.memo는 오직 props변화에만 의존하는 최적화 방법이다.

6. useEffect
   useEffect는 hook을 사용해서 컴포넌트가 마운트 됐을 때, 언마운트 됐을 때, 업데이트 될때(특정 props이 바뀔때) 특정작업을 하도록 도와주는 hook 함수입니다.
